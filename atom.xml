<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>田祚的个人博客</title>
  
  <subtitle>贫，气不改；达，志不改</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-07-04T05:12:02.393Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>田祚</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>线程和进程</title>
    <link href="http://yoursite.com/2019/07/04/1/"/>
    <id>http://yoursite.com/2019/07/04/1/</id>
    <published>2019-07-04T03:24:40.000Z</published>
    <updated>2019-07-04T05:12:02.393Z</updated>
    
    <content type="html"><![CDATA[<h1 id="线程和进程"><a href="#线程和进程" class="headerlink" title="线程和进程"></a>线程和进程</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>进程（process）：是指具有已一定功能的独立程序，是系统资源分配的基本单位，在内存中有其完备的数据空间和代码空间，拥有完整的虚拟空间地址。一个进程所拥有的数据和变量只属于它自己。</p><p>线程（thread）：是进程内相对独立的可执行单元，所以也被称为轻量进程（lightweight processes）；是操作系统进行任务调度的基本单元。它与父进程的其它线程共享该进程所拥有的全部代码空间和全局变量，但拥有独立的堆栈（即<strong>局部变量对于线程来说是私有的</strong>）。</p><h2 id="联系"><a href="#联系" class="headerlink" title="联系"></a>联系</h2><p>进程和线程都具有就绪、阻塞和运行三种基本状态。</p><p> 一个进程至少拥有一个线程——主线程，也可以拥有多个线程；一个线程必须且仅有一个父进程。多个进程可以并发执行；一个线程可以创建和撤销另一个线程；同一个进程中的多个线程之间可以并发执行。</p><p>支援分配给进程，同一进程的所有线程共享该进程的所有资源</p><p>线程在执行过程中，需要协作同步。不同进程的线程间要利用消息通信的办法实现同步</p><p>处理机分给线程，即真正在处理机上运行的是线程</p><p>线程是指进程内的一个执行单元，也是进程内的可调度实体。</p><h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><p>进程和线程的主要差别在于它们是不同的操作系统资源管理方式。当然也在系统开销方面有一些体现。</p><p>系统开销：在创建或撤消进程时，由于系统都要为之分配和回收资源，导致系统的开销明显<strong>大于创建或撤消线程时的开销</strong></p><p>资源管理：进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响，而线程只是一个进程中的不同执行路径。线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，一个线程死掉就等于整个进程死掉，（当一个线程向非法地址读取或者写入，无法确认这个操作是否会影响同一进程中的其它线程，所以只能是整个进程一起崩溃。）所以多进程的程序要比多线程的程序健壮，但在进程切换时，耗费资源较大，效率要差一些。但对于一些要求同时进行并且又要共享某些变量的并发操作，只能用线程，不能用进程。一个进程的开销大约是一个线程开销的30倍左右</p><h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><p>线程和进程在使用上各有优缺点：线程执行开销小，但不利于资源的管理和保护；而进程正相反。同时，线程适合于在SMP机器上运行，而进程则可以跨机器迁移。</p><h2 id="多进程单线程模型"><a href="#多进程单线程模型" class="headerlink" title="多进程单线程模型"></a>多进程单线程模型</h2><p>master进程管理worker进程：</p><ul><li>接收来自外界的信号</li><li>向各worker进程发送信号</li><li>监控woker进程的运行状态</li><li>当woker进程退出后（异常情况下），会自动重新启动新的woker进程</li></ul><p><img src="http://www.2cto.com/shouce/Nginx/_images/chapter-2-1.PNG" alt></p><p>这种模型提供了一种保护机制。<strong>当其中一个进程内部读取错误，master可以让错误进程重启。这使得你的服务器在表面上并没有感到“曾经崩溃”。</strong></p><p>对于<strong>master</strong>，完全不涉及服务器的业务，使得错误进程能被安全隔离。</p><h2 id="单进程多线程"><a href="#单进程多线程" class="headerlink" title="单进程多线程"></a>单进程多线程</h2><p>主线程负责监听客户端的连接请求，workers线程负责处理已经建立好的连接的读写等事件</p><p><img src="/images/Picture1.jpg" alt></p><p><strong>一旦其中出现一个错误，整个进程都有可能挂掉。你当然可以为此进程编写一个“守护程序”来重启，但是重启期间，你的服务器是真的“挂掉了”。</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;线程和进程&quot;&gt;&lt;a href=&quot;#线程和进程&quot; class=&quot;headerlink&quot; title=&quot;线程和进程&quot;&gt;&lt;/a&gt;线程和进程&lt;/h1&gt;&lt;h2 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概
      
    
    </summary>
    
    
      <category term="线程" scheme="http://yoursite.com/tags/%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="进程" scheme="http://yoursite.com/tags/%E8%BF%9B%E7%A8%8B/"/>
    
      <category term="线程和进程" scheme="http://yoursite.com/tags/%E7%BA%BF%E7%A8%8B%E5%92%8C%E8%BF%9B%E7%A8%8B/"/>
    
  </entry>
  
</feed>
